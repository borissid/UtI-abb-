<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Navigation with Videos and Page Scrolling</title>
  <style>
    /* Import Roboto font */
    @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap');

    /* Full viewport and disable native scrolling */
    html,
    body {
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      font-family: 'Roboto', sans-serif;
      background-color: rgba(255, 255, 255, 0);
    }

    /* Canvas container for dots background */
    #canvas-container {
      position: fixed;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      z-index: 1; /* Above body, below active views */
      pointer-events: none;
      display: none; /* Initially hidden */
    }
    
    canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    /* Controls for adjusting the grid */
    #controls {
      position: fixed;
      top: 10px;
      right: 10px;
      background-color: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 5px;
      font-family: Arial, sans-serif;
      font-size: 14px;
      z-index: 1001; /* Higher than other elements */
      display: none; /* Initially hidden */
    }
    
    #controls label {
      display: block;
      margin-bottom: 5px;
    }
    
    #controls input {
      margin-bottom: 10px;
      width: 100%;
    }

    /* Views container */
    #views-container {
      width: 100vw;
      height: 100vh;
      position: relative;
      z-index: 2; /* Above canvas container */
    }

    /* Individual view */
    .view {
      width: 100vw;
      height: 100vh;
      position: absolute;
      top: 0;
      left: 0;
      display: none; /* All views are hidden by default */
      z-index: 1;
    }

    /* Active view */
    .view.active {
      display: block;
      z-index: 2;
    }

    /* Root view with videos */
    #root-view {
      background-color: #f8f8f800; /* Light gray background */
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      height: 100%;
    }

    /* Internet Structure view - explicitly transparent */
    #internetstructure-view {
      background-color: transparent;
    }

    /* Counterculture view - explicitly transparent */
    #counterculture-view {
      background-color: transparent;
    }

    /* Videos container */
    #videos-container {
      display: flex;
      gap: 30px;
      justify-content: center;
      align-items: center;
      width: 100%;
      max-width: 800px;
      padding: 20px;
    }

    /* Video container */
    .video-container {
      width: 300px;
      height: 300px;
      overflow: hidden;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      cursor: pointer;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      position: relative;
      flex-shrink: 0;
      background-color: #ddd; /* Light gray background as placeholder */
    }

    /* Video hover effect */
    .video-container:hover {
      transform: scale(1.1);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
    }

    /* Video */
    .video-container video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    /* Minimized video in corner */
    .minimized-video {
      position: fixed;
      top: 20px;
      left: 20px;
      width: 210px; /* 70% of 300px */
      height: 210px; /* 70% of 300px */
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      z-index: 1000;
      cursor: pointer;
      transition: all 0.5s ease;
      overflow: hidden;
      background-color: #ddd; /* Light gray background as placeholder */
      opacity: 1;
      display: none; /* Initially hidden */
    }

    .minimized-video:hover {
      transform: scale(1.05);
    }

    .minimized-video video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    /* Animation classes for video transition */
    .video-animating {
      position: fixed;
      z-index: 1000;
      transition: all 0.5s ease;
    }

    #counterculture-content {
      text-align: center;
      padding: 30px;
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    /* Page container holds 23 pages (each 100vw wide) */
    #page-container {
      width: 2300vw; /* Updated for 23 pages */
      height: 100vh;
      display: flex;
      transition: transform 0.5s ease-out; /* Simplified easing */
      will-change: transform; /* Optimize for animations */
      background-color: transparent;
    }
    .page {
      width: 100vw;
      height: 100vh;
      position: relative;
      background-color: transparent; /* Transparent for dots background */
    }
    /* Centered info text */
    .info {
      position: absolute;
      top: 10%;
      width: 100%;
      text-align: center;
      font-family: sans-serif;
      color: black;
      cursor: pointer; /* Indicate clickable */
      background-color: rgba(255, 255, 255, 0.7); /* Semi-transparent white */
      padding: 10px 0;
    }
    /* Navigation container ("dynamic corner") */
    #nav-container {
      position: fixed;
      bottom: 40px;
      left: 40px;
      width: 500px; /* visible mask width */
      height: 200px; /* Increased height to accommodate circles */
      overflow: hidden;
      /* Soft horizontal opacity gradient:
         Fully transparent at 0px and 500px,
         fully opaque between 50px and 450px.
      */
      -webkit-mask-image: linear-gradient(to right, transparent 0px, black 50px, black 450px, transparent 500px);
      mask-image: linear-gradient(to right, transparent 0px, black 50px, black 450px, transparent 500px);
      background-color: transparent;
      z-index: 100; /* Ensure it's above other elements for touch events */
      touch-action: none; /* Prevent browser handling of touch gestures */
    }
    
    /* The dynamic long image */
    #nav-container img {
      position: absolute;
      height: 275%;
      bottom: 0;
      left: 0;
      transform: translateX(0px);
      user-select: none;
      pointer-events: none;
      display: block;
      will-change: transform; /* Optimize for animations */
    }
    
    /* Text below the image container */
    #nav-text-container {
      position: fixed;
      bottom: 30px; /* Positioned higher */
      left: 50px;
      width: 500px;
      text-align: left;
      z-index: 101;
    }
    
    /* Text below the image */
    .nav-text {
      font-family: 'Roboto', sans-serif; /* Specific font declaration */
      font-size: 14px;
      color: #333;
      opacity: 1;
      transition: opacity 0.5s ease;
      background-color: rgba(255, 255, 255, 0.7); /* Semi-transparent white */
      padding: 5px;
      border-radius: 3px;
    }
    
    /* Hidden text state */
    .nav-text.hidden {
      opacity: 0;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
    }
    
    /* Position indicators container - moves with the image */
    #position-indicators {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 275%;
      width: 100%;
      transform: translateX(0px);
      pointer-events: none;
      z-index: 10;
      will-change: transform; /* Optimize for animations */
    }
    /* Individual position indicator */
    .position-indicator {
      position: absolute;
      width: 24px;
      height: 24px;
      background-color: #cacaca; /* Soft grey color */
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      color: rgb(158, 158, 158);
      font-family: sans-serif;
      font-size: 12px;
      font-weight: Medium;
      /* Position will be set by JavaScript */
    }
    /* Current indicator highlight */
    .position-indicator.current {
      background-color: #000000; /* Orange-red for current page */
      transform: scale(1.2);
      color: rgb(255, 255, 255);
    }
    /* Indicator: page number display */
    #indicator {
      position: fixed;
      bottom: 95px;
      left: 500px;
      z-index: 20;
      display: flex;
      gap: 5px;
    }
    #indicator span {
      font-family: sans-serif;
      font-size: 14px;
      color: black;
      background-color: rgba(255, 255, 255, 0.8);
      padding: 5px;
      border-radius: 5px;
    }
    /* Current page and zone display */
    #page-info {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 30;
      font-family: sans-serif;
      font-size: 14px;
      color: black;
      background-color: rgba(255, 255, 255, 0.8);
      padding: 5px;
      border-radius: 5px;
    }
    /* Image position display */
    #image-position {
      position: fixed;
      top: 40px;
      right: 10px;
      z-index: 30;
      font-family: sans-serif;
      font-size: 14px;
      color: black;
      background-color: rgba(255, 255, 255, 0.8);
      padding: 5px;
      border-radius: 5px;
    }
    
    /* Debug elements container */
    .debug-elements {
      transition: opacity 0.3s ease;
    }
    
    /* Hidden debug elements */
    .debug-hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    /* Mobile-specific styles */
    @media (max-width: 768px) {
      /* Center the navigation container on mobile */
      #nav-container {
        left: 50%;
        transform: translateX(-50%);
        width: 300px; /* Smaller width for mobile */
        height: 200px; /* Increased height for mobile */
        -webkit-mask-image: linear-gradient(to right, transparent 0px, black 30px, black 270px, transparent 300px);
        mask-image: linear-gradient(to right, transparent 0px, black 30px, black 270px, transparent 300px);
      }
      
      /* Text below the image on mobile */
      #nav-text-container {
        width: 300px;
        left: 50%;
        transform: translateX(-50%);
      }
      
      /* Adjust the indicator position for mobile */
      #indicator {
        bottom: 75px;
        left: 50%;
        transform: translateX(150px); /* Half of nav-container width */
      }
      
      /* Make info text more readable on mobile */
      .info {
        top: 5%;
        font-size: 0.9em;
      }
      
      /* Adjust the info displays for mobile */
      #page-info, #image-position {
        font-size: 12px;
        padding: 3px;
      }
      
      /* Position indicators for mobile */
      .position-indicator {
        width: 20px;
        height: 20px;
        font-size: 10px;
      }

      /* Adjust videos container for mobile */
      #videos-container {
        flex-direction: column;
        gap: 20px;
        padding: 10px;
      }

      /* Smaller videos for mobile */
      .video-container {
        width: 250px;
        height: 250px;
      }

      /* Smaller minimized video for mobile */
      .minimized-video {
        width: 175px;
        height: 175px;
      }
    }
  </style>
</head>
<body>
  <!-- Canvas container for dots background -->
  <div id="canvas-container">
    <canvas id="dotsCanvas"></canvas>
  </div>
  
  <!-- Controls for adjusting the grid -->
  <div id="controls">
    <label for="dotSize">Dot Size: <span id="dotSizeValue">4</span>px</label>
    <input type="range" id="dotSize" min="1" max="20" value="4">
    
    <label for="spacing">Spacing: <span id="spacingValue">40</span>px</label>
    <input type="range" id="spacing" min="10" max="100" value="40">
    
    <label for="padding">Padding: <span id="paddingValue">40</span>px</label>
    <input type="range" id="padding" min="0" max="100" value="40">
    
    <label for="dotColor">Dot Color:</label>
    <input type="color" id="dotColor" value="#cccccc">
  </div>

  <div id="views-container">
    <div id="root-view" class="view active">
      <div id="videos-container">
        <div id="video1" class="video-container">
          <video loop muted playsinline>
            <source src="video/video1.mp4" type="video/mp4">
            Your browser does not support the video tag.
          </video>
        </div>

        <!-- Video 2 container -->
        <div id="video2" class="video-container">
          <video loop muted playsinline>
            <source src="video/video2.mp4" type="video/mp4">
            Your browser does not support the video tag.
          </video>
        </div>
      </div>
    </div>
    
    <!-- Internet Structure view (formerly scrolling view) -->
    <div id="internetstructure-view" class="view">
      <!-- Page container with 23 pages -->
      <div id="page-container">
        <!-- Pages will be generated by JavaScript -->
      </div>

      <!-- Navigation element: dynamic long image -->
      <div id="nav-container">
        <!-- Replace with your long image URL -->
        <img id="nav-img" src="image/dynamiccorner.png" alt="Navigation Image" />
        
        <!-- Position indicators container -->
        <div id="position-indicators">
          <!-- Indicators will be generated by JavaScript -->
        </div>
      </div>
      
      <!-- Text below the image container -->
      <div id="nav-text-container">
        <!-- Zone-specific text elements will be generated by JavaScript -->
      </div>
      
      <!-- Debug elements that can be toggled -->
      <div class="debug-elements debug-hidden">
        <!-- Indicator placed above the nav-container -->
        <div id="indicator">
          <span id="page-number">Page 1 / 23</span>
        </div>

        <!-- Page and zone info display -->
        <div id="page-info">Page: 1, Zone: 1</div>
        
        <!-- Image position display -->
        <div id="image-position">Image Position: 0px</div>
      </div>
    </div>
    
    <!-- Counterculture view (formerly placeholder view) -->
    <div id="counterculture-view" class="view">
      <div id="counterculture-content">
        <h1>Counterculture</h1>
        <p>This is the counterculture page for the second video's destination.</p>
      </div>
    </div>
  </div>

  <!-- Minimized video container (initially hidden) -->
  <div id="minimized-video" class="minimized-video">
    <!-- Video will be cloned here -->
  </div>

  <script>
    // Dots background code
    // Get canvas and context
    const canvas = document.getElementById('dotsCanvas');
    const ctx = canvas.getContext('2d');
    
    // Get controls
    const dotSizeSlider = document.getElementById('dotSize');
    const dotSizeValue = document.getElementById('dotSizeValue');
    const spacingSlider = document.getElementById('spacing');
    const spacingValue = document.getElementById('spacingValue');
    const paddingSlider = document.getElementById('padding');
    const paddingValue = document.getElementById('paddingValue');
    const dotColorPicker = document.getElementById('dotColor');
    
    // Default values
    let dotSize = parseInt(dotSizeSlider.value);
    let spacing = parseInt(spacingSlider.value);
    let padding = parseInt(paddingSlider.value);
    let dotColor = dotColorPicker.value;
    
    // Update values when controls change
    dotSizeSlider.addEventListener('input', function() {
      dotSize = parseInt(this.value);
      dotSizeValue.textContent = dotSize;
      drawDots();
    });
    
    spacingSlider.addEventListener('input', function() {
      spacing = parseInt(this.value);
      spacingValue.textContent = spacing;
      drawDots();
    });
    
    paddingSlider.addEventListener('input', function() {
      padding = parseInt(this.value);
      paddingValue.textContent = padding;
      drawDots();
    });
    
    dotColorPicker.addEventListener('input', function() {
      dotColor = this.value;
      drawDots();
    });
    
    // Resize canvas to fill window
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      drawDots();
    }
    
    // Draw dots in a grid pattern
    function drawDots() {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Calculate number of dots that fit in the canvas
      const numDotsX = Math.floor((canvas.width - (padding * 2)) / spacing) + 1;
      const numDotsY = Math.floor((canvas.height - (padding * 2)) / spacing) + 1;
      
      // Calculate actual padding to center the grid
      const actualPaddingX = (canvas.width - ((numDotsX - 1) * spacing)) / 2;
      const actualPaddingY = (canvas.height - ((numDotsY - 1) * spacing)) / 2;
      
      // Draw dots
      ctx.fillStyle = dotColor;
      
      for (let y = 0; y < numDotsY; y++) {
        for (let x = 0; x < numDotsX; x++) {
          const xPos = actualPaddingX + (x * spacing);
          const yPos = actualPaddingY + (y * spacing);
          
          ctx.beginPath();
          ctx.arc(xPos, yPos, dotSize / 2, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }
    
    // Handle window resize
    window.addEventListener('resize', resizeCanvas);
    
    // Show/hide dots background and controls
    function toggleDotsControls(view) {
      const controls = document.getElementById('controls');
      const canvasContainer = document.getElementById('canvas-container');
      
      if (view === 'root') {
        // Hide dots background and controls in root view
        controls.style.display = 'none';
        canvasContainer.style.display = 'none';
      } else {
        // Show dots background and controls in other views
        controls.style.display = 'block';
        canvasContainer.style.display = 'block';
        
        // Make sure dots are drawn when shown
        setTimeout(() => {
          resizeCanvas();
        }, 10);
      }
    }

    // Main application code
    // DOM Elements
    const rootView = document.getElementById('root-view');
    const internetstructureView = document.getElementById('internetstructure-view');
    const countercultureView = document.getElementById('counterculture-view');
    const video1Container = document.getElementById('video1');
    const video2Container = document.getElementById('video2');
    const video1Element = video1Container.querySelector('video');
    const video2Element = video2Container.querySelector('video');
    const minimizedVideo = document.getElementById('minimized-video');
    const videosContainer = document.getElementById('videos-container');
    
    // Track current view and state
    let currentView = 'root';
    let activeVideoId = null;
    let internetstructureInitialized = false;
    let currentPage = 1;
    let isAnimating = false;
    
    // Initialize videos
    function initVideos() {
      // Start playing the videos
      video1Element.play().catch(e => console.log('Video 1 autoplay prevented:', e));
      video2Element.play().catch(e => console.log('Video 2 autoplay prevented:', e));
      
      // Add loading success logging
      video1Element.addEventListener('loadeddata', function() {
        console.log('Video 1 loaded successfully');
      });
      
      video2Element.addEventListener('loadeddata', function() {
        console.log('Video 2 loaded successfully');
      });
      
      // Add error handling
      video1Element.addEventListener('error', function() {
        console.error('Video 1 failed to load');
        video1Container.innerHTML = '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:#ccc;color:#333;font-size:20px;">Video 1</div>';
      });
      
      video2Element.addEventListener('error', function() {
        console.error('Video 2 failed to load');
        video2Container.innerHTML = '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:#ccc;color:#333;font-size:20px;">Video 2</div>';
      });
    }
    
    // Update URL when switching views
    function updateViewURL(viewName, page = null) {
      const url = new URL(window.location);
      url.searchParams.set('view', viewName);
      
      if (page && viewName === 'internetstructure') {
        url.searchParams.set('page', page);
      } else {
        url.searchParams.delete('page');
      }
      
      window.history.pushState({ view: viewName, page: page }, '', url);
    }
    
    // Get element position for animation
    function getElementPosition(element) {
      const rect = element.getBoundingClientRect();
      return {
        top: rect.top,
        left: rect.left,
        width: rect.width,
        height: rect.height
      };
    }
    
    // Animate video movement
    function animateVideoToCorner(videoId) {
      if (isAnimating) return;
      isAnimating = true;
      
      // Get the source video container
      const sourceContainer = videoId === 'video1' ? video1Container : video2Container;
      const sourceVideo = sourceContainer.querySelector('video');
      
      // Get the starting position of the video
      const startPosition = getElementPosition(sourceContainer);
      
      // Create a clone for animation
      const animatingClone = document.createElement('div');
      animatingClone.className = 'video-animating';
      animatingClone.style.width = `${startPosition.width}px`;
      animatingClone.style.height = `${startPosition.height}px`;
      animatingClone.style.top = `${startPosition.top}px`;
      animatingClone.style.left = `${startPosition.left}px`;
      animatingClone.style.borderRadius = '8px';
      animatingClone.style.overflow = 'hidden';
      animatingClone.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.1)';
      
      // Clone the video
      const videoClone = document.createElement('video');
      videoClone.loop = true;
      videoClone.muted = true;
      videoClone.playsinline = true;
      videoClone.autoplay = true;
      videoClone.style.width = '100%';
      videoClone.style.height = '100%';
      videoClone.style.objectFit = 'cover';
      
      // Add the same source
      const sourceElement = document.createElement('source');
      sourceElement.src = sourceVideo.querySelector('source').src;
      sourceElement.type = 'video/mp4';
      videoClone.appendChild(sourceElement);
      
      // Add to animating clone
      animatingClone.appendChild(videoClone);
      
      // Add to body
      document.body.appendChild(animatingClone);
      
      // Start playing
      videoClone.play().catch(e => console.log('Animation video play prevented:', e));
      
      // Get target position (where minimized video will be)
      const targetWidth = 210; // 70% of 300px
      const targetHeight = 210; // 70% of 300px
      const targetTop = 20;
      const targetLeft = 20;
      
      // Prepare the minimized video in advance but keep it hidden
      minimizeVideo(videoId);
      minimizedVideo.style.opacity = '0';
      minimizedVideo.style.display = 'block';
      
      // Force reflow
      void animatingClone.offsetWidth;
      
      // Start animation to corner
      setTimeout(() => {
        animatingClone.style.width = `${targetWidth}px`;
        animatingClone.style.height = `${targetHeight}px`;
        animatingClone.style.top = `${targetTop}px`;
        animatingClone.style.left = `${targetLeft}px`;
        
        // When animation is 80% complete, start fading in the real minimized video
        setTimeout(() => {
          minimizedVideo.style.opacity = '1';
        }, 400); // 400ms = 80% of 500ms transition
        
        // When animation completes
        animatingClone.addEventListener('transitionend', () => {
          // Remove the animating clone
          document.body.removeChild(animatingClone);
          
          // Animation complete
          isAnimating = false;
        });
      }, 50);
      
      return animatingClone;
    }
    
    // Animate video back to center
    function animateVideoToCenter(videoId) {
      if (isAnimating) return;
      isAnimating = true;
      
      // Get the target container in the root view
      const targetContainer = videoId === 'video1' ? video1Container : video2Container;
      
      // Get the starting position (minimized video)
      const startPosition = getElementPosition(minimizedVideo);
      
      // Get the target position (where video should end up in root view)
      const targetPosition = getElementPosition(targetContainer);
      
      // Create a clone for animation
      const animatingClone = document.createElement('div');
      animatingClone.className = 'video-animating';
      animatingClone.style.width = `${startPosition.width}px`;
      animatingClone.style.height = `${startPosition.height}px`;
      animatingClone.style.top = `${startPosition.top}px`;
      animatingClone.style.left = `${startPosition.left}px`;
      animatingClone.style.borderRadius = '8px';
      animatingClone.style.overflow = 'hidden';
      animatingClone.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.1)';
      
      // Clone the video
      const videoClone = document.createElement('video');
      videoClone.loop = true;
      videoClone.muted = true;
      videoClone.playsinline = true;
      videoClone.autoplay = true;
      videoClone.style.width = '100%';
      videoClone.style.height = '100%';
      videoClone.style.objectFit = 'cover';
      
      // Add the same source
      const sourceElement = document.createElement('source');
      sourceElement.src = minimizedVideo.querySelector('video source').src;
      sourceElement.type = 'video/mp4';
      videoClone.appendChild(sourceElement);
      
      // Add to animating clone
      animatingClone.appendChild(videoClone);
      
      // Add to body
      document.body.appendChild(animatingClone);
      
      // Fade out minimized video
      minimizedVideo.style.opacity = '0';
      
      // Start playing
      videoClone.play().catch(e => console.log('Animation video play prevented:', e));
      
      // Force reflow
      void animatingClone.offsetWidth;
      
      // Start animation to center
      setTimeout(() => {
        animatingClone.style.width = `${targetPosition.width}px`;
        animatingClone.style.height = `${targetPosition.height}px`;
        animatingClone.style.top = `${targetPosition.top}px`;
        animatingClone.style.left = `${targetPosition.left}px`;
        
        // When animation completes
        animatingClone.addEventListener('transitionend', () => {
          // Hide minimized video completely
          minimizedVideo.style.display = 'none';
          minimizedVideo.style.opacity = '1';
          minimizedVideo.innerHTML = '';
          
          // Remove the animating clone
          document.body.removeChild(animatingClone);
          
          // Now that animation is complete, show the root videos
          video1Element.play().catch(e => console.log('Video 1 play prevented:', e));
          video2Element.play().catch(e => console.log('Video 2 play prevented:', e));
          
          // Animation complete
          isAnimating = false;
        });
      }, 50);
      
      return animatingClone;
    }
    
    // Switch to a specific view
    function switchToView(viewName, videoId = null) {
      // If already animating, don't allow another view switch
      if (isAnimating) return;
      
      // Toggle dots background and controls based on view
      toggleDotsControls(viewName);
      
      // If returning to root view and we have an active video, animate it back
      if (viewName === 'root' && activeVideoId) {
        // First switch to root view but hide the videos
        document.querySelectorAll('.view').forEach(view => {
          view.classList.remove('active');
        });
        
        // Show root view
        rootView.classList.add('active');
        
        // Hide videos in root view until animation completes
        video1Container.style.visibility = 'hidden';
        video2Container.style.visibility = 'hidden';
        
        // Update current view
        currentView = 'root';
        
        // Update URL
        updateViewURL('root');
        
        // Store active video ID before resetting
        const tempVideoId = activeVideoId;
        activeVideoId = null;
        
        // Animate the video back to center
        const animatingClone = animateVideoToCenter(tempVideoId);
        
        // After animation, make videos visible again
        setTimeout(() => {
          video1Container.style.visibility = 'visible';
          video2Container.style.visibility = 'visible';
        }, 500); // Match the animation duration
        
        return;
      }
      
      // For transitions to other views with video minimization
      if (videoId) {
        // First animate the video to corner
        const animatingClone = animateVideoToCorner(videoId);
        
        // After animation starts, continue with view switch
        setTimeout(() => {
          // Hide all views
          document.querySelectorAll('.view').forEach(view => {
            view.classList.remove('active');
          });
          
          // Show selected view
          const targetView = document.getElementById(viewName + '-view');
          if (targetView) {
            targetView.classList.add('active');
          } else {
            // Fallback to root view if target view doesn't exist
            rootView.classList.add('active');
            viewName = 'root';
          }
          
          // Update current view
          currentView = viewName;
          
          // Update URL
          const isFromURLHandler = new Error().stack.includes('handleURLParameters');
          if (!isFromURLHandler) {
            if (viewName === 'internetstructure') {
              updateViewURL(viewName, currentPage);
            } else {
              updateViewURL(viewName);
            }
          }
          
          // Update active video ID
          activeVideoId = videoId;
          
          // Initialize internetstructure view if needed
          if (viewName === 'internetstructure' && !internetstructureInitialized) {
            initializeInternetStructureView();
            internetstructureInitialized = true;
          }
        }, 50);
      } else {
        // Standard view switch without video animation
        // Hide all views
        document.querySelectorAll('.view').forEach(view => {
          view.classList.remove('active');
        });
        
        // Show selected view
        const targetView = document.getElementById(viewName + '-view');
        if (targetView) {
          targetView.classList.add('active');
        } else {
          // Fallback to root view if target view doesn't exist
          rootView.classList.add('active');
          viewName = 'root';
        }
        
        // Update current view
        currentView = viewName;
        
        // Update URL
        const isFromURLHandler = new Error().stack.includes('handleURLParameters');
        if (!isFromURLHandler) {
          if (viewName === 'internetstructure') {
            updateViewURL(viewName, currentPage);
          } else {
            updateViewURL(viewName);
          }
        }
        
        // Hide minimized video
        minimizedVideo.style.display = 'none';
        activeVideoId = null;
        
        // Resume playing videos in root view
        if (viewName === 'root') {
          video1Element.play().catch(e => console.log('Video 1 play prevented:', e));
          video2Element.play().catch(e => console.log('Video 2 play prevented:', e));
        }
        
        // Initialize internetstructure view if needed
        if (viewName === 'internetstructure' && !internetstructureInitialized) {
          initializeInternetStructureView();
          internetstructureInitialized = true;
        }
      }
    }
    
    // Minimize video to corner
    function minimizeVideo(videoId) {
      // Clear previous content
      minimizedVideo.innerHTML = '';
      
      // Get the source video element
      const sourceVideo = videoId === 'video1' ? video1Element : video2Element;
      
      // Clone the video
      const videoClone = document.createElement('video');
      videoClone.loop = true;
      videoClone.muted = true;
      videoClone.playsinline = true;
      videoClone.autoplay = true;
      
      // Add the same source
      const sourceElement = document.createElement('source');
      sourceElement.src = sourceVideo.querySelector('source').src;
      sourceElement.type = 'video/mp4';
      videoClone.appendChild(sourceElement);
      
      // Add to minimized container
      minimizedVideo.appendChild(videoClone);
      
      // Start playing
      videoClone.play().catch(e => console.log('Minimized video play prevented:', e));
    }
    
    // Set up event listeners for videos
    function setupVideoListeners() {
      // Video 1 click - go to internetstructure view
      video1Container.addEventListener('click', () => {
        switchToView('internetstructure', 'video1');
      });
      
      // Video 2 click - go to counterculture view
      video2Container.addEventListener('click', () => {
        switchToView('counterculture', 'video2');
      });
      
      // Minimized video click - return to root view
      minimizedVideo.addEventListener('click', () => {
        switchToView('root');
      });
    }
    
    // Handle URL parameters
    function handleURLParameters() {
      const urlParams = new URLSearchParams(window.location.search);
      const viewParam = urlParams.get('view');
      const pageParam = urlParams.get('page');
      
      if (viewParam) {
        switch(viewParam.toLowerCase()) {
          case 'root':
            // Make sure we don't show any minimized video
            minimizedVideo.style.display = 'none';
            activeVideoId = null;
            switchToView('root', null);
            break;
          case 'internetstructure':
            // Initialize internetstructure view if needed
            if (!internetstructureInitialized) {
              initializeInternetStructureView();
              internetstructureInitialized = true;
            }
            switchToView('internetstructure', 'video1');
            
            // If page parameter exists, navigate to that page
            if (pageParam) {
              const pageNum = parseInt(pageParam, 10);
              if (!isNaN(pageNum) && pageNum >= 1 && pageNum <= 23) {
                setTimeout(() => {
                  navigateToPage(pageNum, 0, false);
                }, 100);
              }
            }
            break;
          case 'counterculture':
            switchToView('counterculture', 'video2');
            break;
          default:
            // Default to root view for unknown parameters
            switchToView('root', null);
        }
      } else if (pageParam) {
        // If only page parameter exists, go to internetstructure view
        if (!internetstructureInitialized) {
          initializeInternetStructureView();
          internetstructureInitialized = true;
        }
        switchToView('internetstructure', 'video1');
        
        // Navigate to the specified page
        const pageNum = parseInt(pageParam, 10);
        if (!isNaN(pageNum) && pageNum >= 1 && pageNum <= 23) {
          setTimeout(() => {
            navigateToPage(pageNum, 0, false);
          }, 100);
        }
      } else {
        // Default to root view if no parameters
        switchToView('root', null);
      }
    }
    
    // Handle browser back/forward buttons
    window.addEventListener('popstate', (event) => {
      if (event.state) {
        if (event.state.view) {
          // If we have a view in state, switch to it
          if (event.state.view === 'internetstructure') {
            if (!internetstructureInitialized) {
              initializeInternetStructureView();
              internetstructureInitialized = true;
            }
            switchToView('internetstructure', 'video1');
            
            // If we also have a page, navigate to it
            if (event.state.page) {
              navigateToPage(event.state.page, 0, false);
            }
          } else if (event.state.view === 'counterculture') {
            switchToView('counterculture', 'video2');
          } else {
            switchToView('root', null);
          }
        } else if (event.state.page) {
          // Legacy support for old URLs with only page parameter
          if (!internetstructureInitialized) {
            initializeInternetStructureView();
            internetstructureInitialized = true;
          }
          switchToView('internetstructure', 'video1');
          navigateToPage(event.state.page, 0, false);
        }
      } else {
        // Default to root view if no state
        switchToView('root');
      }
    });
    
    // Initialize internetstructure view (formerly scrolling view)
    function initializeInternetStructureView() {
      // Generate 23 pages dynamically
      const pageContainer = document.getElementById("page-container");
      pageContainer.innerHTML = ''; // Clear any existing pages
      
      for (let i = 1; i <= 23; i++) {
        const page = document.createElement("div");
        page.id = `page${i}`;
        page.className = "page";
        page.innerHTML = `
          <div class="info">
            <h1>Page ${i}</h1>
            <p>Scroll to navigate between pages</p>
          </div>
        `;
        pageContainer.appendChild(page);
      }
      
      // Define the main zone positions (anchor points)
      const zonePositions = [0, -1200, -6400, -8000];
      
      // Map pages to zones (which pages belong to which zone)
      const pageToZoneMap = {
        // Pages 1-8 are in zone 1
        1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 
        // Pages 9-15 are in zone 2
        9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1, 15: 1,
        // Pages 16-18 are in zone 3
        16: 2, 17: 2, 18: 2,
        // Pages 19-23 are in zone 4
        19: 3, 20: 3, 21: 3, 22: 3, 23: 3 
      };
      
      // Define zone-specific text
      const zoneTexts = [
        "Google Data Center Toronto, Canada (northamerica-northeast2)",
        "Hudson Interexchange (IXP), 60 Hudson Street, New York",
        "NorthC Amsterdam (AMS01), Kabelweg 48a, Amsterdam",
        "Edisonstraat, Eindhoven"
      ];
      
      // Calculate positions for each page with normalized spacing within zones
      const pagePositions = {};
      
      // For each zone, calculate positions with equal spacing
      for (let page = 1; page <= 23; page++) {
        const zoneIndex = pageToZoneMap[page];
        
        // Find all pages in this zone
        const pagesInZone = Object.entries(pageToZoneMap)
          .filter(([_, zone]) => zone === zoneIndex)
          .map(([p, _]) => parseInt(p));
        
        // Sort pages in zone
        pagesInZone.sort((a, b) => a - b);
        
        // Find position of current page in the zone's page list
        const positionInZone = pagesInZone.indexOf(page);
        
        // Get zone start position
        const zoneStart = zonePositions[zoneIndex];
        
        // Calculate position with equal spacing between pages in the same zone
        const SPACING_PER_PAGE = 50; // Fixed spacing between pages in the same zone
        
        // Calculate position: zone start + page offset
        pagePositions[page] = zoneStart - (positionInZone * SPACING_PER_PAGE);
      }
      
      // Get initial page from URL parameter or default to 1
      function getInitialPage() {
        const urlParams = new URLSearchParams(window.location.search);
        const pageParam = urlParams.get('page');
        
        if (pageParam) {
          const pageNumber = parseInt(pageParam, 10);
          // Validate page number is in range
          if (!isNaN(pageNumber) && pageNumber >= 1 && pageNumber <= 23) {
            return pageNumber;
          }
        }
        
        return 1; // Default to page 1
      }
      
      // Update URL with current page parameter
      function updateURLParameter(page) {
        // Create new URL with updated page parameter
        const url = new URL(window.location);
        url.searchParams.set('view', 'internetstructure');
        url.searchParams.set('page', page);
        
        // Update URL without reloading the page
        window.history.pushState({ view: 'internetstructure', page: page }, '', url);
      }
      
      // Toggle debug elements visibility
      function toggleDebugElements() {
        const debugElements = document.querySelector('.debug-elements');
        debugElements.classList.toggle('debug-hidden');
      }
      
      // Create text elements for each zone
      function createZoneTextElements() {
        const container = document.getElementById('nav-text-container');
        container.innerHTML = '';
        
        // Create a text element for each zone
        for (let i = 0; i < zoneTexts.length; i++) {
          const textElement = document.createElement('div');
          textElement.className = 'nav-text' + (i === 0 ? '' : ' hidden'); // First zone text visible by default
          textElement.id = `zone-text-${i}`;
          textElement.textContent = zoneTexts[i];
          container.appendChild(textElement);
        }
      }
      
      // Update zone text visibility based on current zone
      function updateZoneText(newZoneIndex, animate = true) {
        const textElements = document.querySelectorAll('.nav-text');
        
        if (animate) {
          // First hide all text elements
          textElements.forEach(el => {
            el.classList.add('hidden');
          });
          
          // After a short delay, show the text for the new zone
          setTimeout(() => {
            textElements.forEach((el, index) => {
              if (index === newZoneIndex) {
                el.classList.remove('hidden');
              } else {
                el.classList.add('hidden');
              }
            });
          }, 1000); // Half a second delay for fade out/in effect
        } else {
          // Immediately update without animation
          textElements.forEach((el, index) => {
            if (index === newZoneIndex) {
              el.classList.remove('hidden');
            } else {
              el.classList.add('hidden');
            }
          });
        }
      }
      
      // Current page (1-based) - initialized from URL parameter
      currentPage = getInitialPage();
      
      // Current zone index (0-based) - initialized based on current page
      let currentZoneIndex = pageToZoneMap[currentPage];
      
      // Current image position - initialized based on current page
      let currentImagePosition = pagePositions[currentPage];
      
      // Scrolling disabled flag (during transition)
      let scrollingDisabled = false;
      
      // Default transition duration (ms)
      const defaultDuration = 1000;
      
      // Flag to track if we're in a touch sequence
      let isTouching = false;
      
      // DOM elements
      const navImg = document.getElementById("nav-img");
      const navContainer = document.getElementById("nav-container");
      const positionIndicators = document.getElementById("position-indicators");
      const pageNumber = document.getElementById("page-number");
      const pageInfo = document.getElementById("page-info");
      const imagePosition = document.getElementById("image-position");
      
      // Create position indicators for each page
      function createPositionIndicators() {
        // Clear existing indicators
        positionIndicators.innerHTML = '';
        
        // Create an indicator for each page
        for (let page = 1; page <= 23; page++) {
          const indicator = document.createElement("div");
          indicator.className = "position-indicator";
          indicator.id = `indicator-${page}`;
          indicator.textContent = page;
          
          // Calculate the horizontal position based on page position
          const xPos = Math.abs(pagePositions[page]);
          
          // Position the indicator - moved higher up
          indicator.style.left = `${xPos + 250}px`; // Center the indicator horizontally on the position
          indicator.style.bottom = '150px'; // Positioned higher above the bottom of the image
          
          // Add the indicator to the container
          positionIndicators.appendChild(indicator);
        }
        
        // Highlight the current page indicator
        updateCurrentIndicator();
      }
      
      // Update the current indicator highlight
      function updateCurrentIndicator() {
        // Remove highlight from all indicators
        document.querySelectorAll('.position-indicator').forEach(ind => {
          ind.classList.remove('current');
        });
        
        // Add highlight to current page indicator
        const currentIndicator = document.getElementById(`indicator-${currentPage}`);
        if (currentIndicator) {
          currentIndicator.classList.add('current');
        }
      }
      
      // Check if device is mobile
      const isMobile = () => window.matchMedia("(max-width: 768px)").matches;
      
      // Navigate to a specific page
      function navigateToPage(targetPage, duration = 500, updateURL = true) {
        if (scrollingDisabled || targetPage === currentPage) return;
        
        // Validate target page
        targetPage = Math.max(1, Math.min(23, targetPage));
        
        scrollingDisabled = true;
        
        const previousPage = currentPage;
        const previousZone = currentZoneIndex;
        
        // Update current page
        currentPage = targetPage;
        
        // Update URL if requested
        if (updateURL) {
          updateURLParameter(currentPage);
        }
        
        // Update page container position
        pageContainer.style.transition = duration > 0 ? `transform ${duration}ms ease-out` : 'none';
        pageContainer.style.transform = `translateX(-${(currentPage - 1) * 100}vw)`;
        
        // Update page number display
        pageNumber.textContent = `Page ${currentPage} / 23`;
        
        // Get the zone for the current page
        const newZoneIndex = pageToZoneMap[currentPage];
        
        // Update zone info
        pageInfo.textContent = `Page: ${currentPage}, Zone: ${newZoneIndex + 1}`;
        
        // Get the target position for the current page
        const targetPosition = pagePositions[currentPage];
        currentImagePosition = targetPosition;
        
        // Update image position display
        imagePosition.textContent = `Image Position: ${Math.round(targetPosition)}px`;
        
        // Update the current indicator highlight
        updateCurrentIndicator();
        
        // Determine transition duration based on zone change
        let imageDuration = duration;
        
        // Check if zone has changed
        if (newZoneIndex !== previousZone) {
            // Update zone text with animation
            updateZoneText(newZoneIndex, duration > 0);
            
            // Special case for transition between zones 2 and 3
            if (duration > 0 && ((previousZone === 1 && newZoneIndex === 2) ||
                (previousZone === 2 && newZoneIndex === 1))) {
              imageDuration = 3000; // Longer transition between zones 2 and 3
            } else if (duration > 0) {
              imageDuration = defaultDuration; // Default for zone transitions
            }
            
            // Update current zone index
            currentZoneIndex = newZoneIndex;
        }
        
        // Trigger image transition to the new position
        triggerTransition(targetPosition, imageDuration);
        
        // Reset page container transition after it completes
        setTimeout(() => {
          pageContainer.style.transition = `transform 0.5s ease-out`;
          scrollingDisabled = false;
        }, Math.max(duration, imageDuration));
      }
      
      // Handle both wheel and touch events
      function setupEventListeners() {
        // Mouse wheel event for desktop
        document.addEventListener("wheel", handleScrollEvent, { passive: false });
        
        // Add click event to page titles to toggle debug info
        document.addEventListener("click", (e) => {
          // Check if the click was on a page title
          if (e.target.closest('.info')) {
            toggleDebugElements();
          }
        });
        
        // Variables for horizontal swipe on the image
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        let swipeVelocity = 0;
        let lastTouchTime = 0;
        let lastTouchX = 0;
        
        // Add horizontal swipe only to the nav container
        navContainer.addEventListener("touchstart", (e) => {
          if (scrollingDisabled) return;
          
          isTouching = true;
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
          lastTouchX = touchStartX;
          lastTouchTime = Date.now();
          
          // Prevent default to avoid scrolling the page
          e.preventDefault();
        }, { passive: false });
        
        navContainer.addEventListener("touchmove", (e) => {
          if (scrollingDisabled || !isTouching) return;
          
          // Calculate velocity for momentum effect
          const now = Date.now();
          const touchX = e.touches[0].clientX;
          const dt = now - lastTouchTime;
          
          if (dt > 0) {
            // pixels per millisecond
            swipeVelocity = (touchX - lastTouchX) / dt;
          }
          
          lastTouchX = touchX;
          lastTouchTime = now;
          
          // Prevent default to avoid scrolling the page
          e.preventDefault();
        }, { passive: false });
        
        navContainer.addEventListener("touchend", (e) => {
          if (scrollingDisabled || !isTouching) return;
          
          isTouching = false;
          touchEndX = e.changedTouches[0].clientX;
          touchEndY = e.changedTouches[0].clientY;
          
          // Calculate horizontal and vertical distance
          const deltaX = touchStartX - touchEndX;
          const deltaY = touchStartY - touchEndY;
          
          // Only handle horizontal swipes (ignore if more vertical than horizontal)
          if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 30) {
            // Calculate number of pages to move based on velocity and distance
            // This creates the momentum effect
            let pagesToMove = 1; // Default is 1 page
            
            // Scale based on swipe velocity (pixels per millisecond)
            // Adjust these thresholds based on testing
            const absVelocity = Math.abs(swipeVelocity);
            
            if (absVelocity > 1.5) {
              pagesToMove = 3; // Very fast swipe - reduced from 4 to 3
            } else if (absVelocity > 1.0) {
              pagesToMove = 2; // Fast swipe - reduced from 3 to 2
            } else if (absVelocity > 0.5) {
              pagesToMove = 1; // Medium swipe - reduced from 2 to 1
            }
            
            // Limit pages to move based on available pages
            if (deltaX > 0) { // Swipe left (move forward)
              pagesToMove = Math.min(pagesToMove, 23 - currentPage);
            } else { // Swipe right (move backward)
              pagesToMove = Math.min(pagesToMove, currentPage - 1);
            }
            
            // Handle the swipe
            handleSwipe(deltaX, pagesToMove);
          }
          
          // Reset velocity
          swipeVelocity = 0;
          
          // Prevent default to avoid scrolling the page
          e.preventDefault();
        }, { passive: false });
        
        // Handle touch cancel to reset state
        navContainer.addEventListener("touchcancel", () => {
          isTouching = false;
          swipeVelocity = 0;
        }, { passive: true });
        
        // Vertical swipe for the rest of the page (original behavior)
        document.addEventListener("touchstart", (e) => {
          // Skip if the touch is on the nav container (already handled)
          if (e.target.closest('#nav-container')) return;
          
          touchStartY = e.changedTouches[0].screenY;
        }, { passive: true });
        
        document.addEventListener("touchend", (e) => {
          // Skip if the touch is on the nav container (already handled)
          if (e.target.closest('#nav-container') || scrollingDisabled) return;
          
          touchEndY = e.changedTouches[0].screenY;
          const deltaY = touchStartY - touchEndY;
          
          // Simulate wheel event with touch delta
          if (Math.abs(deltaY) > 30) { // Threshold to avoid small swipes
            handleScrollEvent({ 
              preventDefault: () => {}, 
              deltaY: deltaY,
              deltaMode: 0
            });
          }
        }, { passive: true });
      }
      
      // Handle horizontal swipe
      function handleSwipe(deltaX, pagesToMove) {
        if (scrollingDisabled) return;
        
        // Determine direction
        const direction = deltaX > 0 ? 1 : -1; // 1 for forward, -1 for backward
        
        // Calculate target page
        const targetPage = Math.max(1, Math.min(23, currentPage + (direction * pagesToMove)));
        
        // If page would change, update everything
        if (targetPage !== currentPage) {
          // Calculate appropriate transition duration based on pages moved
          const transitionDuration = Math.min(800, 400 + (pagesToMove * 50)); // Cap at 800ms
          
          // Navigate to the target page
          navigateToPage(targetPage, transitionDuration);
        }
      }
      
      // Handle scroll/swipe events
      function handleScrollEvent(e) {
        if (scrollingDisabled) return;
        
        if (!e.deltaMode) { // Not from a touch event that needs preventDefault
          e.preventDefault();
        }
        
        // Calculate target page based on scroll direction
        let targetPage = currentPage;
        
        if (e.deltaY > 0 && currentPage < 23) {
          targetPage = currentPage + 1;
        } else if (e.deltaY < 0 && currentPage > 1) {
          targetPage = currentPage - 1;
        }
        
        // If page would change, navigate to it
        if (targetPage !== currentPage) {
          navigateToPage(targetPage);
        }
      }
      
      function triggerTransition(targetX, duration) {
        // Apply transition to the image and indicators
        navImg.style.transition = duration > 0 ? `transform ${duration}ms ease-out` : 'none';
        positionIndicators.style.transition = duration > 0 ? `transform ${duration}ms ease-out` : 'none';
        
        // Apply the transform to the image and indicators
        navImg.style.transform = `translateX(${targetX}px)`;
        positionIndicators.style.transform = `translateX(${targetX}px)`;
        
        // Update position display
        imagePosition.textContent = `Image Position: ${Math.round(targetX)}px`;
        
        if (duration > 0) {
          setTimeout(() => {
            navImg.style.transition = "";
            positionIndicators.style.transition = "";
          }, duration);
        }
      }
      
      // Initialize internetstructure view components
      function initialize() {
        createPositionIndicators();
        createZoneTextElements();
        setupEventListeners();
        
        // Set initial container position for mobile
        if (isMobile()) {
          navContainer.style.transform = "translateX(-50%)";
        }
        
        // Set initial page position (without animation if it's not page 1)
        if (currentPage !== 1) {
          // Set initial page without animation
          pageContainer.style.transition = "none";
          pageContainer.style.transform = `translateX(-${(currentPage - 1) * 100}vw)`;
          
          // Set initial image position without animation
          navImg.style.transition = "none";
          positionIndicators.style.transition = "none";
          navImg.style.transform = `translateX(${pagePositions[currentPage]}px)`;
          positionIndicators.style.transform = `translateX(${pagePositions[currentPage]}px)`;
          
          // Update displays
          pageNumber.textContent = `Page ${currentPage} / 23`;
          pageInfo.textContent = `Page: ${currentPage}, Zone: ${currentZoneIndex + 1}`;
          imagePosition.textContent = `Image Position: ${Math.round(pagePositions[currentPage])}px`;
          
          // Update zone text without animation
          updateZoneText(currentZoneIndex, false);
          
          // Force reflow to apply the changes before enabling transitions
          void pageContainer.offsetWidth;
          void navImg.offsetWidth;
          
          // Re-enable transitions
          pageContainer.style.transition = "";
          navImg.style.transition = "";
          positionIndicators.style.transition = "";
          
          // Update the current indicator
          updateCurrentIndicator();
        }
      }
      
      // Handle window resize to update mobile/desktop mode
      window.addEventListener("resize", () => {
        // Reset any container transforms that might have been applied
        if (isMobile()) {
          navContainer.style.transform = "translateX(-50%)";
        } else {
          navContainer.style.transform = "";
        }
        
        // Recreate indicators with proper positioning
        createPositionIndicators();
        
        // Redraw dots when window is resized
        resizeCanvas();
      });
      
      // Make navigateToPage function available globally
      window.navigateToPage = navigateToPage;
      
      // Initialize the internetstructure view
      initialize();
    }
    
    // Initialize everything
    document.addEventListener('DOMContentLoaded', () => {
      // Initialize videos
      initVideos();
      
      // Setup video click handlers
      setupVideoListeners();
      
      // Handle URL parameters
      handleURLParameters();
      
      // Initially hide dots background and controls in root view
      toggleDotsControls('root');
    });
  </script>
</body>
</html>
